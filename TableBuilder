import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class TableBuilder<T> {

    public void tabularise(T[] objects) {
        if (objects == null || objects.length == 0) {
            System.out.println("No data available.");
            return;
        }

        // Get declared methods and sort them alphabetically (or by a custom logic)
        Method[] methods = objects[0].getClass().getDeclaredMethods();
        Arrays.sort(methods, Comparator.comparing(Method::getName));

        // Filter methods to those that should be invoked
        List<Method> filteredMethods = Arrays.stream(methods)
                .filter(this::shouldInvoke)
                .toList();

        // Calculate maximum width for each column
        int[] maxWidths = new int[filteredMethods.size()];
        for (int i = 0; i < filteredMethods.size(); i++) {
            Method method = filteredMethods.get(i);
            maxWidths[i] = prettyName(method.getName()).length(); // Initialize with header length

            // Check all objects for the max length of this column
            for (T t : objects) {
                try {
                    Object value = method.invoke(t);
                    maxWidths[i] = Math.max(maxWidths[i], value.toString().length());
                } catch (Exception e) {
                    System.out.println("Error computing width for " + method.getName() + ": " + e.getMessage());
                }
            }
        }

        // Print headers with appropriate padding
        for (int i = 0; i < filteredMethods.size(); i++) {
            System.out.print(prettyName(filteredMethods.get(i).getName()) + " ".repeat(maxWidths[i] - prettyName(filteredMethods.get(i).getName()).length() + 1));
        }
        System.out.println();

        // Print values with appropriate padding
        for (T t : objects) {
            for (int i = 0; i < filteredMethods.size(); i++) {
                try {
                    Method method = filteredMethods.get(i);
                    Object value = method.invoke(t);
                    String valueString = value.toString();
                    System.out.print(valueString + " ".repeat(maxWidths[i] - valueString.length() + 1));
                } catch (Exception e) {
                    System.out.println("Error invoking " + filteredMethods.get(i).getName() + ": " + e.getMessage());
                }
            }
            System.out.println();
        }
    }

    // Utility method to decide if a method should be invoked
    private boolean shouldInvoke(Method method) {
        return (method.getName().startsWith("get") || method.getName().startsWith("is")) && method.getParameterCount() == 0;
    }

    // Utility method to format method names into more readable form
    private String prettyName(String methodName) {
        if (methodName.startsWith("get") || methodName.startsWith("is")) {
            methodName = methodName.replace("get", "").replace("is", "");
            methodName = Character.toUpperCase(methodName.charAt(0)) + methodName.substring(1);
        }
        return methodName;
    }
}
